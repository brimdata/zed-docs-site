"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[3273],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=r,m=c["".concat(s,".").concat(h)]||c[h]||p[h]||o;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1295:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={},s=void 0,d={unversionedId:"tutorials/lake",id:"tutorials/lake",title:"lake",description:"This document will soon be updated as part of issue 3604",source:"@site/docs/tutorials/lake.md",sourceDirName:"tutorials",slug:"/tutorials/lake",permalink:"/docs/tutorials/lake",editUrl:"https://github.com/brimdata/zed-docs/tree/main/docs/tutorials/lake.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Join Primer",permalink:"/docs/tutorials/join"},next:{title:"A Tour of Zed with Schools Data",permalink:"/docs/tutorials/schools"}},u={},p=[{value:"Test data",id:"test-data",level:2},{value:"Ingesting the data",id:"ingesting-the-data",level:2},{value:"Initializing the archive",id:"initializing-the-archive",level:2},{value:"Counting as &quot;hello world&quot;",id:"counting-as-hello-world",level:2},{value:"Search for an IP",id:"search-for-an-ip",level:2},{value:"Indexes",id:"indexes",level:2},{value:"Creating more indexes",id:"creating-more-indexes",level:2},{value:"Operating directly on indexes",id:"operating-directly-on-indexes",level:2},{value:"Custom indexes: Storing aggregations in an index",id:"custom-indexes-storing-aggregations-in-an-index",level:2},{value:"<code>zed find</code> with custom index",id:"zed-find-with-custom-index",level:2},{value:"Multi-key custom indexes",id:"multi-key-custom-indexes",level:2},{value:"Map-reduce",id:"map-reduce",level:2},{value:"Simple graph queries",id:"simple-graph-queries",level:2},{value:"A final word about pipes...",id:"a-final-word-about-pipes",level:2},{value:"Cleanup",id:"cleanup",level:2}],c={toc:p};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"This document will soon be updated as part of issue 3604")),(0,o.kt)("h1",{id:"zed-lake-tutorial"},"Zed lake tutorial"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"DISCLAIMER: This tutorial was drafted assuming on an older version of the\nZed lake design and is out of date.  We will soon update this document\nto reflect our more recent ",(0,o.kt)("a",{parentName:"p",href:"/docs/zed/"},"Git-inspired design"),".")),(0,o.kt)("hr",null),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A video walk-through of some of what's shown below is captured in\n",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=ldrEadAQYTM&t=46m00s"},"this excerpt from a recent Zeek From Home event"),".")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"This documents describes the ",(0,o.kt)("inlineCode",{parentName:"p"},"zed")," command, a work-in-progress for\nindexing and searching Zed data lakes."),(0,o.kt)("h1",{id:"contents"},"Contents"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#test-data"},"Test data")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ingesting-the-data"},"Ingesting the data")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#initializing-the-archive"},"Initializing the archive")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#counting-as-hello-world"},'Counting as "hello world"')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#search-for-an-ip"},"Search for an IP")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#indexes"},"Indexes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#creating-more-indexes"},"Creating more indexes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#operating-directly-on-indexes"},"Operating directly on indexes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#custom-indexes-storing-aggregations-in-an-index"},"Custom indexes: Storing aggregations in an index")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#zed-lake-find-with-custom-index"},(0,o.kt)("inlineCode",{parentName:"a"},"zed find")," with custom index")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#multi-key-custom-indexes"},"Multi-key custom indexes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#map-reduce"},"Map-reduce")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#simple-graph-queries"},"Simple graph queries")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#a-final-word-about-pipes"},"A final word about pipes...")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#cleanup"},"Cleanup"))),(0,o.kt)("h2",{id:"test-data"},"Test data"),(0,o.kt)("p",null,"We'll use the ",(0,o.kt)("a",{parentName:"p",href:"/docs/formats/zng"},"ZNG"),"-format test data from here:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"https://github.com/brimdata/zed-sample-data/tree/main/zng\n")),(0,o.kt)("p",null,"You can copy just the zng data directory needed for this demo\ninto your current directory using subversion:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"svn checkout https://github.com/brimdata/zed-sample-data/trunk/zng\n")),(0,o.kt)("p",null,"Or, you can clone the whole data repo using git and symlink the zng dir:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"git clone --depth=1 https://github.com/brimdata/zed-sample-data.git\nln -s zed-sample-data/zng\n")),(0,o.kt)("h2",{id:"ingesting-the-data"},"Ingesting the data"),(0,o.kt)("p",null,"Let's take those logs and ingest them into a directory.  Often we'd keep our\narchive somewhere like ",(0,o.kt)("a",{parentName:"p",href:"https://aws.amazon.com/s3/"},"Amazon S3"),", but since we're\njust doing a quick test we'll use local temp space.  We'll make it easier to\nrun all the commands by setting an environment variable pointing to the root of\nthe logs tree."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"export ZED_LAKE=/tmp/logs\nmkdir $ZED_LAKE\n")),(0,o.kt)("p",null,"Now, let's ingest the data using ",(0,o.kt)("inlineCode",{parentName:"p"},"zed load"),".  We are working on more\nsophisticated ways to ingest data (e.g., arbitrary partition keys and\nauto-sizing of partitions) but for now ",(0,o.kt)("inlineCode",{parentName:"p"},"zed load")," just chops its input into\nLZ4-compressed chunk files of approximately equal size, each sorted by\ntimestamp in descending order.  We'll chop into chunks of approximately 25MB\neach, which is very small, but in this example the data set is fairly small\n(71 MB of LZ4-compressed ZNG) and you can always try it out on larger data\nsets:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed load -s 25MB zng/*.gz\n")),(0,o.kt)("h2",{id:"initializing-the-archive"},"Initializing the archive"),(0,o.kt)("p",null,"Try ",(0,o.kt)("inlineCode",{parentName:"p"},"zed ls")," now and you can see the lake directories.  This is where\n",(0,o.kt)("inlineCode",{parentName:"p"},"zed")," puts lots of interesting data associated with each chunk file of the ingested logs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed ls\n")),(0,o.kt)("h2",{id:"counting-as-hello-world"},'Counting as "hello world"'),(0,o.kt)("p",null,"Now that it's set up, you can do stuff with the archive.  Maybe the simplest thing\nis to count up all the events across the archive.  Since the chunk files\nare in different directories in the archive, we need a way to run ",(0,o.kt)("inlineCode",{parentName:"p"},"zed query")," over\nall of them and aggregate the result."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," subcommand of ",(0,o.kt)("inlineCode",{parentName:"p"},"zed")," lets you do this.  Here's how you run ",(0,o.kt)("inlineCode",{parentName:"p"},"zq"),"\non the data of every log in the archive:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed query "count()" > counts.zng\n')),(0,o.kt)("p",null,"This invocation of ",(0,o.kt)("inlineCode",{parentName:"p"},"zed"),' traverses the lake, applies the Zed "count()" operator\non the data from all the chunks, and writes the output as a stream of zng data.\nBy default, the output is sent to stdout, which means you can simply pipe the\nresulting stream to a vanilla ',(0,o.kt)("inlineCode",{parentName:"p"},"zq")," command that specifies ",(0,o.kt)("inlineCode",{parentName:"p"},"-")," to expect the\nstream on stdin, then show the output as a table:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed query "count()" | zq -f table -\n')),(0,o.kt)("p",null,"which, for example, results in:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"count\n1462078\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," common options are also available when invoking ",(0,o.kt)("inlineCode",{parentName:"p"},"zed query"),", so instead of a\npipeline we can get the same result in one shot via:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed query -f table "count()"\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"zed query")," treats the lake as if it were one large set of data, regardless\nof how many chunk files are in it. It's also possible to perform queries for\neach chunk; that's done with a command called ",(0,o.kt)("inlineCode",{parentName:"p"},"zed map"),".\nThis invocation of ",(0,o.kt)("inlineCode",{parentName:"p"},"zed"),"\ntraverses the archive, applies a query to each log file, and writes the output\nto either stdout, or to a new file in the chunk's directory."),(0,o.kt)("p",null,'Here\'s an example using the same "count()" query as before:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map -f text "count()"\n')),(0,o.kt)("p",null,"which results in:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"275745\n276326\n290789\n619218\n")),(0,o.kt)("p",null,"You could take the stream of event counts and sum them to get a total:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map "count()" | zq -f text "sum(count)" -\n')),(0,o.kt)("p",null,"which should have the same result as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq -f text "count()" zng/*.gz\n')),(0,o.kt)("p",null,"or..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"1462078\n")),(0,o.kt)("h2",{id:"search-for-an-ip"},"Search for an IP"),(0,o.kt)("p",null,"Now let's say you want to search for a particular IP across the Zed lake.\nThis is easy. You just say:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed query -Z "id.orig_h=10.10.23.2"\n')),(0,o.kt)("p",null,"which gives this result in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/formats/zson"},"ZSON")," format.  ZSON\ndescribes the complete detail from the ZNG stream as human-readable text."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{\n    _path: "conn",\n    ts: 2018-03-24T17:15:21.307472Z,\n    uid: "C4NuQHXpLAuXjndmi",\n    id: {\n        orig_h: 10.10.23.2,\n        orig_p: 11 (port=(uint16)),\n        resp_h: 10.0.0.111,\n        resp_p: 0 (port)\n    },\n    proto: "icmp" (=zenum),\n    service: null (string),\n    duration: 21m0.819589s,\n    orig_bytes: 23184 (uint64),\n    resp_bytes: 0 (uint64),\n    conn_state: "OTH",\n    local_orig: null (bool),\n    local_resp: null (bool),\n    missed_bytes: 0 (uint64),\n    history: null (string),\n    orig_pkts: 828 (uint64),\n    orig_ip_bytes: 46368 (uint64),\n    resp_pkts: 0 (uint64),\n    resp_ip_bytes: 0 (uint64),\n    tunnel_parents: null (|[string]|)\n}\n')),(0,o.kt)("p",null,"(If you want to learn more about this format, check out the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/formats/zson"},"ZSON spec"),".)"),(0,o.kt)("p",null,"You might have noticed that this is kind of slow --- like all the counting above ---\nbecause every record is read to search for that IP."),(0,o.kt)("p",null,"We can speed this up by building an index.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("inlineCode",{parentName:"p"},"zed")," lets you pretty much build any\nsort of index you'd like and you can even embed whatever custom Zed analytics\nyou would like in a search index.  But for now, let's look at just IP addresses."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE: we are in the process of changing ",(0,o.kt)("inlineCode",{parentName:"p"},"zed index")," to operate over\nspecific key ranges instead of the arbitrary boundaries formed with lake chunks.\nFor now, this describes the old behavior.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"zed index")," command makes it easy to index any field or any Zed type.\ne.g., to index every value that is of type IP, we simply say"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed index create :ip\n")),(0,o.kt)("p",null,"For each Zed lake chunk, this command will find every field of type IP in every\nrecord and add a key for that field's value to chunk's index file."),(0,o.kt)("p",null,"Hmm that was interesting.  If you type"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed ls -l\n")),(0,o.kt)("p",null,"You will see all the indexes left behind. They are just zng files.\nIf you want to see one, just look at it with zq, e.g."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"find $ZED_LAKE -name idx-* | head -n 1 | xargs zq -z -\n")),(0,o.kt)("p",null,"Now if you run ",(0,o.kt)("inlineCode",{parentName:"p"},"zed find"),", it will efficiently look through all the index files\ninstead of the raw lake data and run much faster..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed find -f table :ip=10.10.23.2\n")),(0,o.kt)("p",null,"In the output here, you'll see this IP exists in exactly one lake chunk:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"/tmp/logs/zd/20180324/d-1jQ2dLYVOL4NSSYCYC4P400ZfPN.zng\n")),(0,o.kt)("p",null,"(In this and later outputs in this README that show pathnames in the archive,\nthe portion of the paths following ",(0,o.kt)("inlineCode",{parentName:"p"},"d-")," will be unique and hence differ in your\noutput if you repeat the commands.)"),(0,o.kt)("h2",{id:"indexes"},"Indexes"),(0,o.kt)("p",null,"A Zed index is a zng index file that pertains to just one\nchunk of lake data and represents just one indexing rule.  If you're curious about\nwhat's in the index, it's just a sorted list of keyed records along with some\nadditional zng streams that comprise a constant b-tree index into the sorted list.\nBut the cool thing here is that everything is just a zng stream."),(0,o.kt)("p",null,"Instead of building a massive, inverted index with glorious roaring\nbitmaps that tell you exactly where each event is in the event store, our model\nis to instead build lots of small indexes for each log chunk and index different\nthings in the different indexes.  This approach dovetails with the modern\ncloud warehouse approach of scanning native-cloud storage objets and efficiently\npruning objects that are not needed from the scan."),(0,o.kt)("h2",{id:"creating-more-indexes"},"Creating more indexes"),(0,o.kt)("p",null,"The beauty of this approach is that you can add and delete indexes\nwhenever you want.  No need to suffer the fate of a massive reindexing\njob when you have a new idea about what to index."),(0,o.kt)("p",null,'So, let\'s say you later decide you want searches over the "uri" field to run fast.\nYou just run ',(0,o.kt)("inlineCode",{parentName:"p"},"zed index")," again but with different parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed index create uri\n")),(0,o.kt)("p",null,"And now you can run field matches on ",(0,o.kt)("inlineCode",{parentName:"p"},"uri"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed find -f table uri=/file\n")),(0,o.kt)("p",null,'and you\'ll find "hits" in multiple lake chunks:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"/tmp/logs/zd/20180324/d-1jQ2d5DwDHJULCRN6gq84IwArbb.zng\n/tmp/logs/zd/20180324/d-1jQ2co6Ttjk9wEUdzI2yW7koYtB.zng\n")),(0,o.kt)("h2",{id:"operating-directly-on-indexes"},"Operating directly on indexes"),(0,o.kt)("p",null,"Let's say instead of searching for what lake chunk a value is in, we want to\nactually pull out the zng records that comprise the index.  This turns out\nto be really powerful in general, but to give you a taste here, you can say..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed find -z :ip=10.47.21.138\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"-z")," says to produce compact ZSON output instead of a table,\nand you'll get this..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{key:10.47.21.138,count:1 (uint64),_log:"/tmp/logs/zd/20180324/d-1qCzy6mfDLtsDXeEU1EJxSn1DTi.zng" (=zfile),first:2018-03-24T17:36:30.01359Z,last:2018-03-24T17:15:20.600725Z} (=0)\n{key:10.47.21.138,count:13,_log:"/tmp/logs/zd/20180324/d-1qCzyJtVcZh8fLyFgTJl0fcoyrp.zng",first:2018-03-24T17:29:56.0241Z,last:2018-03-24T17:15:20.601374Z} (0)\n')),(0,o.kt)("p",null,'The find command adds a column called "_log" (which can be disabled\nor customized to a different field name) so you can see where the\nsearch hits came from even when they are combined into a zng stream.\nThe type of the path field is a named type --- a sort of logical type ---\nwhere a client can infer the type "zfile" refers to a zng data file.'),(0,o.kt)("p",null,"But, what if we wanted to put even more information in the index\nalongside each key?  If we could, it seems we could do arbitrarily\ninteresting things with this..."),(0,o.kt)("h2",{id:"custom-indexes-storing-aggregations-in-an-index"},"Custom indexes: Storing aggregations in an index"),(0,o.kt)("p",null,"Since everything is a zng file, you can create whatever values you want to\ngo along with your index keys using Zed queries.  Why don't we go back to counting?"),(0,o.kt)("p",null,"Let's create an index keyed on the field id.orig_h and for each unique value of\nthis key, we'll compute the number of times that value appeared for each zeek\nlog type.  To do this, we'll run ",(0,o.kt)("inlineCode",{parentName:"p"},"zed index")," in a way that leaves\nthese results behind in each lake directory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed index create -q -o custom.zng -k id.orig_h -z "count() by _path, id.orig_h | sort id.orig_h"\n')),(0,o.kt)("p",null,"Unlike for the field and type indexes we created previously, for\ncustom indexes the index file name must be specified via the ",(0,o.kt)("inlineCode",{parentName:"p"},"-o"),"\nflag.  You can run ls to see the custom index files are indeed there:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed ls custom.zng\n")),(0,o.kt)("p",null,"To see what's in it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"find $ZED_LAKE -name idx-$(zed index ls -f zng | zq -f text 'desc=\"zed-custom.zng\" | cut id' -).zng | head -n 1 | xargs zq -f table 'head 10' -\n")),(0,o.kt)("p",null,"You can see the IPs, counts, and _path strings."),(0,o.kt)("p",null,"At the bottom you'll also find a record describing the index layout. To\nsee it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"find $ZED_LAKE -name idx-$(zed index ls -f zng | zq -f text 'desc=\"zed-custom.zng\" | cut id' -).zng | head -n 1 | xargs zq -f table 'tail 1' -\n")),(0,o.kt)("h2",{id:"zed-find-with-custom-index"},(0,o.kt)("inlineCode",{parentName:"h2"},"zed find")," with custom index"),(0,o.kt)("p",null,"And now I can go back to my example from before and use ",(0,o.kt)("inlineCode",{parentName:"p"},"zed find")," on the custom\nindex:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed find -z -x custom.zng 10.164.94.120\n")),(0,o.kt)("p",null,"Now we're talking!  And if you take the results and do a little more math to\naggregate the aggregations, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed find -x custom.zng 10.164.94.120 | zq -f table "count=sum(count) by _path | sort -r" -\n')),(0,o.kt)("p",null,"You'll get"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"_path       count\nconn        26726\nhttp        13485\nssl         9538\nrdp         4116\nsmtp        1178\nweird       316\nftp         93\nntlm        80\nsmb_mapping 65\nnotice      35\ndpd         24\ndns         8\nrfb         3\ndce_rpc     2\nssh         1\nsmb_files   1\n")),(0,o.kt)("p",null,"We can compute this aggregation now for any IP in the index\nwithout reading any of the original data files!  You'll get the same\noutput from this..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq "id.orig_h=10.164.94.120" zng/*.gz | zq -f table "count() by _path | sort -r" -\n')),(0,o.kt)("p",null,"But using ",(0,o.kt)("inlineCode",{parentName:"p"},"zed")," with the custom indexes is MUCH faster.  Pretty cool."),(0,o.kt)("h2",{id:"multi-key-custom-indexes"},"Multi-key custom indexes"),(0,o.kt)("p",null,'In addition to a single-key search, you can build indexes with multiple keys\nin each row.  To do this, you list the keys in order\nof precedence, e.g., primary, secondary, etc.  Then, you can perform searches\nusing one or more keys in that order where any missing keys are "don\'t cares"\nand will match all search rows with any value.'),(0,o.kt)("p",null,"For example, let's say we want to build an index that has primary key\n",(0,o.kt)("inlineCode",{parentName:"p"},"id.resp_h")," and secondary key ",(0,o.kt)("inlineCode",{parentName:"p"},"id.orig_h")," from all the conn logs where we\ncache the sum of response bytes to each originator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed index create -o custom2.zng -k id.resp_h,id.orig_h -z "_path=conn | resp_bytes=sum(resp_bytes) by id.resp_h,id.orig_h | sort id.resp_h,id.orig_h"\n')),(0,o.kt)("p",null,"And now we can search with a primary key and a secondary key, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed find -Z -x custom2.zng 216.58.193.206 10.47.6.173\n")),(0,o.kt)("p",null,"which produces just one record as this pair appears in only one log file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{\n    id: {\n        resp_h: 216.58.193.206,\n        orig_h: 10.47.6.173\n    },\n    resp_bytes: 5112 (uint64),\n    _log: "/tmp/logs/zd/20180324/d-1q85q79hAjNCHg5Wx0EQlkulmKU.zng" (=zfile),\n    first: 2018-03-24T17:29:56.0241Z,\n    last: 2018-03-24T17:15:20.601374Z\n} (=0)\n')),(0,o.kt)("p",null,"The nice thing here is that you can also just specify a primary key, which will\nissue a search that returns all the index hits that have the primary key with\nany value for the secondary key, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed find -z -x custom2.zng 216.58.193.206\n")),(0,o.kt)("p",null,"and of course you can sum up all the response bytes to get a table and output\nit as text..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed find -x custom2.zng 216.58.193.206 | zq -f text "sum(resp_bytes)" -\n')),(0,o.kt)("p",null,'Note that you can\'t "wild card" the primary key when doing a search via\n',(0,o.kt)("inlineCode",{parentName:"p"},"zed find")," because the index is sorted by primary key first, then secondary\nkey, and so forth, and efficient lookups are carried out by traversing the\nb-tree index structure of these sorted keys.  But remember,\neverything is a zng file, so you can do a brute-force search on the base-layer\nof the index, e.g., to look for all the instances of a value in the secondary\nkey position (ignoring the primary key) by using\n",(0,o.kt)("inlineCode",{parentName:"p"},"zed map")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"zed find"),"."),(0,o.kt)("p",null,"So, let's say we wanted\na count of all bytes received by 10.47.6.173 as the originator, which is the\nsecondary key.  While we could build a different custom index where ",(0,o.kt)("inlineCode",{parentName:"p"},"id.orig_h"),"\nis the primary key, we could also just scan the custom2 index using brute force:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map id.orig_h=10.47.6.173 idx-$(zed index ls -f zng | zq -f text \'desc="zed-custom2.zng" | cut id\' -).zng | zq -f text "sum(resp_bytes)" -\n')),(0,o.kt)("p",null,'Even though this is a "brute force scan", it\'s a brute force scan of only this\none index so it runs much faster than scanning all of the original\nlog data to perform the same query.'),(0,o.kt)("p",null,"But to double check here, you can run"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map id.orig_h=10.47.6.173 | zq -f text "sum(resp_bytes)" -\n')),(0,o.kt)("p",null,"and you will get the same answer."),(0,o.kt)("h2",{id:"map-reduce"},"Map-reduce"),(0,o.kt)("p",null,"What's really going on here is map-reduce style computation on your log archives\nwithout having to set up a spark cluster and write java map-reduce classes."),(0,o.kt)("p",null,"The classic map-reduce example is word count.  Let's do this example with\nthe uri field in http logs.  First, we map each record that has a uri\nto a new record with that uri and a count of 1:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map -q -o words.zng "uri != null | cut uri | put count=1"\n')),(0,o.kt)("p",null,"again you can look at one of the files..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"find $ZED_LAKE -name words.zng ! -size 0 | head -n 1 | xargs zq -z -\n")),(0,o.kt)("p",null,"Now we reduce by aggregating the uri and summing the counts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map -q -o wordcounts.zng "sum(count) by uri | cut uri,count=sum" words.zng\n')),(0,o.kt)("p",null,"If we were dealing with a huge archive, we could do an approximation by taking\nthe top 1000 in each lake directory then we could aggregate with another zq\ncommand at the top-level:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map "sort -r count | head 1000" wordcounts.zng | zq -f table "sum(count) by uri | sort -r sum | head 10" -\n')),(0,o.kt)("p",null,"and you get the top-ten URIs..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"uri                     sum\n/wordpress/wp-login.php 6516\n/                       5848\n/api/get/3/6            4677\n/api/get/1/2            4645\n/api/get/4/7            4639\n/api/get/2/3            4638\n/api/get/4/8            4638\n/api/get/1/1            4636\n/api/get/6/12           4634\n/api/get/9/18           4627\n")),(0,o.kt)("p",null,"Pretty cool!"),(0,o.kt)("h2",{id:"simple-graph-queries"},"Simple graph queries"),(0,o.kt)("p",null,"Here is another example to illustrate the power of ",(0,o.kt)("inlineCode",{parentName:"p"},"zed"),".  Just like you can\nbuild search indexes with arbitrary Zed queries, you can also build graph indexes\nto hold edge lists and node attributes, providing an efficient means to do\ntopological queries of graph data structures.  While this doesn't provide a\nfull-featured graph database like ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/neo4j/neo4j"},"neo4j"),",\nit does provide a nice way to do many types of graph queries that\ncould prove useful for your archive analytics."),(0,o.kt)("p",null,"For example, to build a searchable edge list comprising communicating IP addresses,\nrun the following commands to a create a multi-key search index\nkeyed by all unique instances of IP address pairs (in both directions)\nwhere each index includes a count of the occurrences."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed map -o forward.zng "id.orig_h != null | put from_addr=id.orig_h,to_addr=id.resp_h | count() by from_addr,to_addr"\nzed map -o reverse.zng "id.orig_h != null | put from_addr=id.resp_h,to_addr=id.orig_h | count() by from_addr,to_addr"\nzed map -o directed-pairs.zng "count=sum(count) by from_addr,to_addr | sort from_addr,to_addr" forward.zng reverse.zng\nzed index create -i directed-pairs.zng -o graph.zng -k from_addr,to_addr -z "*"\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"(Note: there is a small change we can make to the Zed language to do this with one\ncommand... coming soon.)")),(0,o.kt)("p",null,'This creates an index called "graph" that you can use to search for IP address\npair relationships, e.g., you can say'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed find -x graph.zng 216.58.193.195 | zq -f table "count=sum(count) by from_addr,to_addr | sort -r count" -\n')),(0,o.kt)("p",null,"to get a listing of all of the edges from IP 216.58.193.195 to any other IP,\nwhich looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"from_addr      to_addr      count\n216.58.193.195 10.47.2.155  55\n216.58.193.195 10.47.2.100  47\n216.58.193.195 10.47.6.162  31\n216.58.193.195 10.47.7.150  30\n216.58.193.195 10.47.5.153  26\n216.58.193.195 10.47.3.154  25\n216.58.193.195 10.47.5.152  24\n216.58.193.195 10.47.8.19   23\n216.58.193.195 10.47.7.154  19\n...\n")),(0,o.kt)("p",null,"To view this with d3, we can collect up the edges emanating from a few IP addresses\nand format the output as NDJSON in the format expected by bostock's\nforce-directed graph.\nThis command sequence will collect up the edges into ",(0,o.kt)("inlineCode",{parentName:"p"},"edges.njdson"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zed find -z -x graph.zng 216.58.193.195 | zq "count() by from_addr,to_addr" - > edges.zng\nzed find -z -x graph.zng 10.47.6.162 | zq "count() by from_addr,to_addr" - >> edges.zng\nzed find -z -x graph.zng 10.47.5.153 | zq "count() by from_addr,to_addr" - >> edges.zng\nzq -f json "value=sum(count) by from_addr,to_addr | cut source=from_addr,target=to_addr,value" edges.zng >> edges.ndjson\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"(Note: with a few additions to Zed, we can make this much simpler and\nmore efficient.  Coming soon.  Also, we should be able to say ",(0,o.kt)("inlineCode",{parentName:"p"},"group by node"),",\nwhich implies no reducer and emits columns with just the group-by keys.)")),(0,o.kt)("p",null,"Now that we have the edges in ",(0,o.kt)("inlineCode",{parentName:"p"},"edges.ndjson"),", let's grab all the nodes\nin the graph and put them in the form expected by bostock using this command sequence:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq "count() by from_addr | put id=from_addr" edges.zng > nodes.zng\nzq "count() by to_addr | put id=to_addr" edges.zng >> nodes.zng\nzq -f json "count() by id | cut id | put addr_group=1" nodes.zng > nodes.ndjson\n')),(0,o.kt)("p",null,"To make a simple demo of this concept here, I cut and paste the nodes and edges\ndata into a gist and added some commas with ",(0,o.kt)("inlineCode",{parentName:"p"},"awk"),".  Check out this\n",(0,o.kt)("a",{parentName:"p",href:"https://bl.ocks.org/mccanne/ff6f703cf202aee59197fff1f63d04fe"},'d3 "block"'),"."),(0,o.kt)("h2",{id:"a-final-word-about-pipes"},"A final word about pipes..."),(0,o.kt)("p",null,"As you've likely noticed, we love pipes in the zq project. Make a test file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq "head 10000" zng/* > pipes.zng\n')),(0,o.kt)("p",null,"You can use pipes in Zed expressions like you've seen above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq -f table "orig_bytes > 100 | count() by id.resp_p | sort -r" pipes.zng\n')),(0,o.kt)("p",null,"Or you can pipe the output of one zq to another..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq "orig_bytes > 100 | count() by id.resp_p" pipes.zng | zq -f table "sort -r" -\n')),(0,o.kt)("p",null,"We were careful to make the output of zq just a stream of zng records.\nSo whether you are piping within a Zed query, or between zq commands, or\nbetween zed and zq, or over the network (ssh zq...), it's all the same."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq "orig_bytes > 100" pipes.zng | zq "count() by id.resp_p" - | zq -f table "sort -r" -\n')),(0,o.kt)("p",null,"In fact, files are self-contained zng streams, so you can just cat them together\nand you still end up with a valid zng stream"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'cat pipes.zng pipes.zng > pipes2.zng\nzq -f text "count()" pipes.zng\nzq -f text "count()" pipes2.zng\n')),(0,o.kt)("h2",{id:"cleanup"},"Cleanup"),(0,o.kt)("p",null,"To clean out all the files you've created in the lake directories and\nstart over, just run"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"zed rmdirs $ZED_LAKE\n")))}h.isMDXComponent=!0}}]);